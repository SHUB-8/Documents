# ai-services/transaction-sage/service.py
"""
Transaction-Sage: Handles transaction execution and annotation
"""

import os
import uuid
import jwt
import logging
import requests
import asyncio
from datetime import datetime
from typing import Dict, Any, Optional
from fastapi import FastAPI, HTTPException, Depends, Header
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session

from .schemas.transaction_execute import TransferExecuteRequest, DepositExecuteRequest, TransactionResponse
from .schemas.annotate_transaction import AnnotateTransactionRequest, AnnotationResponse
from .merchant_normalizer import MerchantNormalizer
from .category_model import CategoryClassifier
from .config import TransactionSageConfig
from ..ai_meta_db.models import get_db
from ..ai_meta_db.repository.ai_meta_repository import AIMetaRepository
from ..shared.logging_utils import setup_logging
from ..shared.exceptions import AuthenticationError, ValidationError, InsufficientFundsError
from ..shared.utils import validate_account_number, generate_transaction_id

# Setup logging
logger = setup_logging("transaction-sage")

app = FastAPI(title="Transaction-Sage", version="1.0.0")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize configuration
config = TransactionSageConfig()
merchant_normalizer = MerchantNormalizer()
category_classifier = CategoryClassifier()

def verify_token(authorization: str = Header(...)) -> Dict[str, str]:
    """Verify JWT token and extract user data"""
    try:
        if not authorization.startswith("Bearer "):
            raise AuthenticationError("Invalid authorization header")
        
        token = authorization[7:]
        
        if not config.jwt_public_key:
            logger.warning("No JWT public key configured")
            payload = jwt.decode(token, options={"verify_signature": False})
        else:
            payload = jwt.decode(token, config.jwt_public_key, algorithms=['RS256'])
        
        return {
            'username': payload.get('user'),
            'account_id': payload.get('acct'),
            'name': payload.get('name'),
            'token': token
        }
    except jwt.exceptions.InvalidTokenError as e:
        logger.error(f"Token validation failed: {e}")
        raise AuthenticationError("Invalid token")
    except Exception as e:
        logger.error(f"Authentication error: {e}")
        raise AuthenticationError("Authentication failed")

@app.get("/health")
def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "transaction-sage"}

@app.post("/transfer", response_model=TransactionResponse)
async def execute_transfer(request: TransferExecuteRequest,
                          user_data: Dict[str, str] = Depends(verify_token),
                          db: Session = Depends(get_db)):
    """Execute money transfer"""
    try:
        account_id = user_data.get('account_id')
        token = user_data.get('token')
        
        if not account_id:
            raise HTTPException(status_code=400, detail="Account ID not found in token")
        
        # Validate amount
        try:
            amount_clean = request.amount.replace("$", "").replace(",", "")
            amount_float = float(amount_clean)
            if amount_float <= 0:
                raise ValidationError("Amount must be greater than zero")
            if amount_float > 10000:  # Same limit as original
                raise ValidationError("Transfer amount exceeds daily limit of $10,000")
        except ValueError:
            raise ValidationError("Invalid amount format")
        
        amount_cents = int(amount_float * 100)
        
        # Validate recipient account
        if not validate_account_number(request.recipient_account):
            raise ValidationError("Invalid recipient account number")
        
        # Get pre-transaction balance
        pre_balance = await _get_account_balance(token)
        
        # Execute transfer via core ledger service
        result = await _execute_core_transfer(
            token, account_id, request.recipient_account, amount_cents
        )
        
        if result.get("status") == "success":
            # Get updated balance
            new_balance = "Unknown"
            for attempt in range(5):
                await asyncio.sleep(0.3)
                balance_result = await _get_account_balance(token)
                if balance_result != pre_balance:
                    new_balance = balance_result
                    break
            
            # Create annotation in AI-Meta DB
            try:
                repo = AIMetaRepository(db)
                annotation = repo.create_transaction_annotation(
                    transaction_id=result.get("transaction_id", 0),  # Would get real ID from response
                    account_id=account_id,
                    merchant_name=f"Transfer to {request.recipient_account}",
                    category="Transfer"
                )
                logger.info(f"Created transaction annotation: {annotation.annotation_id}")
            except Exception as e:
                logger.warning(f"Failed to create annotation: {e}")
            
            return TransactionResponse(
                status="success",
                transaction_id=result.get("transaction_id"),
                new_balance=new_balance,
                message=f"Successfully transferred ${amount_float:,.2f} to {request.recipient_account}"
            )
        else:
            return TransactionResponse(
                status="error",
                error_message=result.get("error_message", "Transfer failed")
            )
            
    except ValidationError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except InsufficientFundsError as e:
        raise HTTPException(status_code=402, detail=str(e))
    except Exception as e:
        logger.error(f"Transfer execution error: {e}")
        raise HTTPException(status_code=500, detail="Unable to complete transfer")

@app.post("/deposit", response_model=TransactionResponse)
async def execute_deposit(request: DepositExecuteRequest,
                         user_data: Dict[str, str] = Depends(verify_token),
                         db: Session = Depends(get_db)):
    """Execute money deposit"""
    try:
        account_id = user_data.get('account_id')
        token = user_data.get('token')
        
        if not account_id:
            raise HTTPException(status_code=400, detail="Account ID not found in token")
        
        # Validate amount
        try:
            amount_clean = request.amount.replace("$", "").replace(",", "")
            amount_float = float(amount_clean)
            if amount_float <= 0:
                raise ValidationError("Amount must be greater than zero")
            if amount_float > 50000:  # Same limit as original
                raise ValidationError("Deposit amount exceeds limit of $50,000")
        except ValueError:
            raise ValidationError("Invalid amount format")
        
        amount_cents = int(amount_float * 100)
        
        # Get pre-transaction balance
        pre_balance = await _get_account_balance(token)
        
        # Execute deposit via core ledger service
        result = await _execute_core_deposit(token, account_id, amount_cents)
        
        if result.get("status") == "success":
            # Get updated balance
            new_balance = "Unknown"
            for attempt in range(5):
                await asyncio.sleep(0.3)
                balance_result = await _get_account_balance(token)
                if balance_result != pre_balance:
                    new_balance = balance_result
                    break
            
            # Create annotation
            try:
                repo = AIMetaRepository(db)
                annotation = repo.create_transaction_annotation(
                    transaction_id=result.get("transaction_id", 0),
                    account_id=account_id,
                    merchant_name="External Deposit",
                    category="Deposit"
                )
                logger.info(f"Created deposit annotation: {annotation.annotation_id}")
            except Exception as e:
                logger.warning(f"Failed to create annotation: {e}")
            
            return TransactionResponse(
                status="success",
                transaction_id=result.get("transaction_id"),
                new_balance=new_balance,
                message=f"Successfully deposited ${amount_float:,.2f}"
            )
        else:
            return TransactionResponse(
                status="error",
                error_message=result.get("error_message", "Deposit failed")
            )
            
    except ValidationError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Deposit execution error: {e}")
        raise HTTPException(status_code=500, detail="Unable to complete deposit")

@app.post("/annotate", response_model=AnnotationResponse)
async def annotate_transaction(request: AnnotateTransactionRequest,
                              user_data: Dict[str, str] = Depends(verify_token),
                              db: Session = Depends(get_db)):
    """Annotate transaction with merchant and category info"""
    try:
        account_id = user_data.get('account_id')
        
        if not account_id:
            raise HTTPException(status_code=400, detail="Account ID not found in token")
        
        repo = AIMetaRepository(db)
        
        # Normalize merchant name if provided
        merchant_name = request.merchant_name
        category = request.category
        
        if request.merchant_name:
            merchant_name = merchant_normalizer.normalize_merchant_name(request.merchant_name)
            
            # Get or create merchant
            merchant = repo.get_or_create_merchant(merchant_name, category)
            
            # Auto-categorize if category not provided
            if not category:
                category = category_classifier.predict_category(merchant_name, request.amount_cents)
        
        # Create annotation
        annotation = repo.create_transaction_annotation(
            transaction_id=request.transaction_id,
            account_id=account_id,
            merchant_name=merchant_name,
            category=category,
            user_note=request.user_note
        )
        
        return AnnotationResponse(
            status="success",
            annotation_id=str(annotation.annotation_id),
            merchant_name=merchant_name,
            category=category,
            message="Transaction annotated successfully"
        )
        
    except Exception as e:
        logger.error(f"Transaction annotation error: {e}")
        raise HTTPException(status_code=500, detail="Unable to annotate transaction")

async def _get_account_balance(token: str) -> Optional[str]:
    """Get account balance from core service"""
    try:
        url = f"http://{config.balance_api_addr}/balances/current"  # Simplified endpoint
        headers = {"Authorization": f"Bearer {token}"}
        
        response = requests.get(url, headers=headers, timeout=config.backend_timeout)
        
        if response.status_code == 200:
            try:
                balance_data = response.json()
                balance = balance_data.get('balance', 0) if isinstance(balance_data, dict) else balance_data
                balance_dollars = balance / 100 if balance > 10000 else balance
                return f"${balance_dollars:,.2f}"
            except:
                balance = float(response.text.strip())
                balance_dollars = balance / 100 if balance > 10000 else balance
                return f"${balance_dollars:,.2f}"
        
        return None
        
    except Exception as e:
        logger.error(f"Balance check error: {e}")
        return None

async def _execute_core_transfer(token: str, from_account: str, to_account: str, amount_cents: int) -> Dict[str, Any]:
    """Execute transfer via core ledger service"""
    try:
        url = f"http://{config.ledger_api_addr}/transactions"
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }
        
        transaction_id = generate_transaction_id("txn")
        
        payload = {
            "fromAccountNum": from_account,
            "fromRoutingNum": config.local_routing_num,
            "toAccountNum": to_account,
            "toRoutingNum": config.local_routing_num,
            "amount": amount_cents,
            "uuid": transaction_id
        }
        
        response = requests.post(url, headers=headers, json=payload, timeout=config.backend_timeout)
        
        if response.status_code == 201:
            return {
                "status": "success",
                "transaction_id": transaction_id
            }
        elif response.status_code == 402:
            return {
                "status": "error",
                "error_message": "Insufficient funds"
            }
        else:
            return {
                "status": "error",
                "error_message": "Transfer service unavailable"
            }
            
    except requests.exceptions.Timeout:
        return {"status": "error", "error_message": "Transfer service timeout"}
    except Exception as e:
        logger.error(f"Core transfer error: {e}")
        return {"status": "error", "error_message": "Transfer service error"}

async def _execute_core_deposit(token: str, to_account: str, amount_cents: int) -> Dict[str, Any]:
    """Execute deposit via core ledger service using external funding account"""
    try:
        # For now, use a placeholder external account
        # In practice, this would come from user's linked external accounts
        external_account = "1111111111"
        external_routing = "021000021"  # Example external bank routing
        
        url = f"http://{config.ledger_api_addr}/transactions"
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }
        
        transaction_id = generate_transaction_id("deposit")
        
        payload = {
            "fromAccountNum": external_account,
            "fromRoutingNum": external_routing,
            "toAccountNum": to_account,
            "toRoutingNum": config.local_routing_num,
            "amount": amount_cents,
            "uuid": transaction_id
        }
        
        response = requests.post(url, headers=headers, json=payload, timeout=config.backend_timeout)
        
        if response.status_code == 201:
            return {
                "status": "success", 
                "transaction_id": transaction_id
            }
        else:
            return {
                "status": "error",
                "error_message": "Deposit service unavailable"
            }
            
    except Exception as e:
        logger.error(f"Core deposit error: {e}")
        return {"status": "error", "error_message": "Deposit service error"}

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", "8080"))
    uvicorn.run(app, host="0.0.0.0", port=port)

# ai-services/transaction-sage/schemas/transaction_execute.py
"""
Transaction execution schemas
"""

from pydantic import BaseModel, Field
from typing import Optional, Dict, Any

class TransferExecuteRequest(BaseModel):
    """Request to execute money transfer"""
    amount: str = Field(..., description="Amount to transfer (e.g., '100.00')")
    recipient_account: str = Field(..., description="Recipient account number")
    original_currency: Optional[str] = Field(None, description="Original currency if converted")
    original_amount: Optional[float] = Field(None, description="Original amount before conversion")
    note: Optional[str] = Field(None, description="Optional transfer note")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional metadata")

class DepositExecuteRequest(BaseModel):
    """Request to execute money deposit"""
    amount: str = Field(..., description="Amount to deposit (e.g., '500.00')")
    source_account: Optional[str] = Field(None, description="External source account")
    original_currency: Optional[str] = Field(None, description="Original currency if converted")
    original_amount: Optional[float] = Field(None, description="Original amount before conversion")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional metadata")

class TransactionResponse(BaseModel):
    """Response from transaction execution"""
    status: str = Field(..., description="Transaction status: success, error")
    transaction_id: Optional[str] = Field(None, description="Generated transaction ID")
    new_balance: Optional[str] = Field(None, description="Updated account balance")
    message: Optional[str] = Field(None, description="Success message")
    error_message: Optional[str] = Field(None, description="Error details if failed")

# ai-services/transaction-sage/schemas/annotate_transaction.py
"""
Transaction annotation schemas
"""

from pydantic import BaseModel, Field
from typing import Optional

class AnnotateTransactionRequest(BaseModel):
    """Request to annotate transaction"""
    transaction_id: int = Field(..., description="Transaction ID to annotate")
    merchant_name: Optional[str] = Field(None, description="Merchant name")
    category: Optional[str] = Field(None, description="Transaction category")
    amount_cents: Optional[int] = Field(None, description="Transaction amount for auto-categorization")
    user_note: Optional[str] = Field(None, description="User note")

class AnnotationResponse(BaseModel):
    """Response from transaction annotation"""
    status: str = Field(..., description="Annotation status: success, error")
    annotation_id: Optional[str] = Field(None, description="Created annotation ID")
    merchant_name: Optional[str] = Field(None, description="Normalized merchant name")
    category: Optional[str] = Field(None, description="Assigned category")
    message: Optional[str] = Field(None, description="Success message")
    error_message: Optional[str] = Field(None, description="Error details if failed")

# ai-services/transaction-sage/merchant_normalizer.py
"""
Merchant name normalization logic
"""

import re
import logging
from typing import Dict, Set

logger = logging.getLogger(__name__)

class MerchantNormalizer:
    """Normalizes merchant names for consistent categorization"""
    
    def __init__(self):
        # Common merchant patterns and their normalized forms
        self.merchant_patterns = {
            r'(?i)amazon.*': 'Amazon',
            r'(?i)walmart.*': 'Walmart',
            r'(?i)target.*': 'Target',
            r'(?i)starbucks.*': 'Starbucks',
            r'(?i)mcdonalds?.*': 'McDonald\'s',
            r'(?i)uber.*': 'Uber',
            r'(?i)netflix.*': 'Netflix',
            r'(?i)spotify.*': 'Spotify',
            r'(?i)gas.*station.*': 'Gas Station',
            r'(?i)grocery.*': 'Grocery Store',
            r'(?i)pharmacy.*': 'Pharmacy',
            r'(?i)bank.*fee.*': 'Bank Fee'
        }
        
        # Words to remove from merchant names
        self.noise_words = {
            'inc', 'llc', 'corp', 'ltd', 'co', 'company',
            'store', 'shop', 'market', 'center', 'centre',
            'payment', 'pay', 'transaction', 'purchase'
        }
    
    def normalize_merchant_name(self, raw_name: str) -> str:
        """
        Normalize merchant name to standard form
        
        Args:
            raw_name: Raw merchant name from transaction
            
        Returns:
            Normalized merchant name
        """
        if not raw_name:
            return "Unknown Merchant"
        
        # Check against known patterns first
        for pattern, normalized in self.merchant_patterns.items():
            if re.match(pattern, raw_name):
                return normalized
        
        # Generic normalization
        normalized = self._generic_normalize(raw_name)
        
        logger.debug(f"Normalized '{raw_name}' -> '{normalized}'")
        return normalized
    
    def _generic_normalize(self, name: str) -> str:
        """Apply generic normalization rules"""
        # Convert to lowercase for processing
        name = name.lower().strip()
        
        # Remove special characters and extra spaces
        name = re.sub(r'[^\w\s]', ' ', name)
        name = re.sub(r'\s+', ' ', name)
        
        # Remove common noise words
        words = name.split()
        filtered_words = []
        
        for word in words:
            if word not in self.noise_words and len(word) > 1:
                filtered_words.append(word)
        
        if not filtered_words:
            return "Unknown Merchant"
        
        # Capitalize first letter of each word
        normalized = ' '.join(word.capitalize() for word in filtered_words)
        
        return normalized

# ai-services/transaction-sage/category_model.py
"""
Transaction categorization model
"""

import logging
from typing import Dict, Optional

logger = logging.getLogger(__name__)

class CategoryClassifier:
    """Classifies transactions into categories"""
    
    def __init__(self):
        # Merchant to category mappings
        self.merchant_categories = {
            'amazon': 'Shopping',
            'walmart': 'Groceries',
            'target': 'Shopping',
            'starbucks': 'Dining',
            'mcdonalds': 'Dining',
            'uber': 'Transportation',
            'netflix': 'Entertainment',
            'spotify': 'Entertainment',
            'gas station': 'Transportation',
            'grocery store': 'Groceries',
            'pharmacy': 'Health',
            'bank fee': 'Fees'
        }
        
        # Amount-based category hints
        self.amount_categories = {
            'small_purchase': 'Misc',      # < $20
            'medium_purchase': 'Shopping', # $20-$200
            'large_purchase': 'Major Purchase',  # > $200
        }
    
    def predict_category(self, merchant_name: str, amount_cents: Optional[int] = None) -> str:
        """
        Predict transaction category based on merchant and amount
        
        Args:
            merchant_name: Normalized merchant name
            amount_cents: Transaction amount in cents
            
        Returns:
            Predicted category
        """
        if not merchant_name:
            return "Uncategorized"
        
        # Check merchant-based categories first
        merchant_lower = merchant_name.lower()
        
        for merchant_key, category in self.merchant_categories.items():
            if merchant_key in merchant_lower:
                return category
        
        # Fall back to amount-based categorization
        if amount_cents:
            amount_dollars = amount_cents / 100
            
            if amount_dollars < 20:
                return "Misc"
            elif amount_dollars < 200:
                return "Shopping"
            else:
                return "Major Purchase"
        
        # Default category
        return "Uncategorized"
    
    def get_available_categories(self) -> list[str]:
        """Get list of available categories"""
        return [
            "Groceries", "Dining", "Shopping", "Transportation", 
            "Entertainment", "Health", "Utilities", "Fees",
            "Major Purchase", "Transfer", "Deposit", "Misc", "Uncategorized"
        ]

# ai-services/transaction-sage/config.py
"""
Configuration for Transaction-Sage service
"""

import os
import base64

class TransactionSageConfig:
    """Configuration for Transaction-Sage"""
    
    def __init__(self):
        # Core service addresses
        self.ledger_api_addr = os.getenv('TRANSACTIONS_API_ADDR', 'ledgerwriter:8080')
        self.balance_api_addr = os.getenv('BALANCES_API_ADDR', 'balancereader:8080')
        self.contacts_api_addr = os.getenv('CONTACTS_API_ADDR', 'contacts:8080')
        
        # Banking settings
        self.local_routing_num = os.getenv('LOCAL_ROUTING_NUM', '883745000')
        
        # Authentication
        self.jwt_public_key = self._load_public_key()
        
        # Service settings
        self.backend_timeout = int(os.getenv('BACKEND_TIMEOUT', '10'))
        
    def _load_public_key(self) -> str:
        """Load JWT public key"""
        try:
            public_key_path = "/tmp/.ssh/publickey"
            if os.path.exists(public_key_path):
                with open(public_key_path, 'r') as f:
                    return f.read()
            
            public_key_b64 = os.getenv('JWT_PUBLIC_KEY')
            if public_key_b64:
                return base64.b64decode(public_key_b64).decode('utf-8')
                
            return None
        except Exception as e:
            print(f"Error loading public key: {e}")
            return None








# ai-services/anomaly-sage/service.py
"""
Anomaly-Sage: Risk assessment and fraud detection
"""

import os
import jwt
import logging
import uuid
from datetime import datetime, time
from typing import Dict, Any, List, Optional
from fastapi import FastAPI, HTTPException, Depends, Header
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session

from .schemas.score_request import AnomalyScoreRequest, AnomalyScoreResponse
from .schemas.score_response import TransactionConfirmRequest, TransactionConfirmResponse
from .risk_model import RiskScoreCalculator
from .thresholds import ThresholdManager
from .email_notifier import EmailNotifier
from .config import AnomalySageConfig
from ..ai_meta_db.models import get_db
from ..ai_meta_db.repository.ai_meta_repository import AIMetaRepository
from ..shared.logging_utils import setup_logging
from ..shared.exceptions import AuthenticationError, ValidationError

# Setup logging
logger = setup_logging("anomaly-sage")

app = FastAPI(title="Anomaly-Sage", version="1.0.0")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize components
config = AnomalySageConfig()
risk_calculator = RiskScoreCalculator()
threshold_manager = ThresholdManager()
email_notifier = EmailNotifier(config.email_config) if config.email_config else None

# In-memory storage for pending confirmations (in production use Redis)
pending_confirmations: Dict[str, Dict[str, Any]] = {}

def verify_token(authorization: str = Header(...)) -> Dict[str, str]:
    """Verify JWT token and extract user data"""
    try:
        if not authorization.startswith("Bearer "):
            raise AuthenticationError("Invalid authorization header")
        
        token = authorization[7:]
        
        if not config.jwt_public_key:
            logger.warning("No JWT public key configured")
            payload = jwt.decode(token, options={"verify_signature": False})
        else:
            payload = jwt.decode(token, config.jwt_public_key, algorithms=['RS256'])
        
        return {
            'username': payload.get('user'),
            'account_id': payload.get('acct'),
            'name': payload.get('name'),
            'token': token
        }
    except jwt.exceptions.InvalidTokenError as e:
        logger.error(f"Token validation failed: {e}")
        raise AuthenticationError("Invalid token")
    except Exception as e:
        logger.error(f"Authentication error: {e}")
        raise AuthenticationError("Authentication failed")

@app.get("/health")
def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "anomaly-sage"}

@app.post("/check-risk", response_model=AnomalyScoreResponse)
async def check_transaction_risk(request: Dict[str, Any],
                                user_data: Dict[str, str] = Depends(verify_token),
                                db: Session = Depends(get_db)):
    """Check transaction for anomalies and risk"""
    try:
        account_id = user_data.get('account_id')
        
        if not account_id:
            raise HTTPException(status_code=400, detail="Account ID not found in token")
        
        # Parse request
        amount = request.get("amount", "0")
        recipient = request.get("recipient", "")
        timestamp = request.get("timestamp") or datetime.now()
        
        # Convert amount to cents
        try:
            amount_clean = str(amount).replace("$", "").replace(",", "")
            amount_float = float(amount_clean)
            amount_cents = int(amount_float * 100)
        except (ValueError, TypeError):
            raise ValidationError("Invalid amount format")
        
        if amount_cents <= 0:
            raise ValidationError("Amount must be greater than zero")
        
        repo = AIMetaRepository(db)
        
        # Get or create user profile
        user_profile = repo.get_or_create_user_profile(account_id)
        
        # Calculate risk score
        risk_assessment = await risk_calculator.calculate_risk_score(
            account_id=account_id,
            amount_cents=amount_cents,
            recipient=recipient,
            timestamp=timestamp,
            user_profile=user_profile,
            repo=repo
        )
        
        risk_score = risk_assessment["risk_score"]
        reasons = risk_assessment["reasons"]
        
        # Determine status and action based on thresholds
        thresholds = threshold_manager.get_user_thresholds(user_profile)
        status, action = threshold_manager.classify_risk(risk_score, thresholds)
        
        # Log anomaly
        anomaly_log = repo.create_anomaly_log(
            transaction_id=0,  # Will be updated when transaction is created
            account_id=account_id,
            risk_score=risk_score,
            status=status,
            reasons=reasons
        )
        
        logger.info(f"Risk assessment: account={account_id}, amount=${amount_float:.2f}, "
                   f"risk_score={risk_score:.4f}, status={status}")
        
        response_data = {
            "status": status,
            "risk_score": risk_score,
            "reasons": reasons,
            "action": action
        }
        
        # Handle different risk levels
        if action == "block":
            response_data["message"] = (
                f"Transaction blocked due to suspicious activity. "
                f"Risk score: {risk_score:.2f}. Reasons: {', '.join(reasons)}"
            )
            return AnomalyScoreResponse(**response_data)
        
        elif action == "confirm":
            # Generate confirmation request
            confirmation_id = str(uuid.uuid4())
            confirmation_code = str(uuid.uuid4())[:8].upper()
            
            pending_confirmations[confirmation_id] = {
                "account_id": account_id,
                "amount_cents": amount_cents,
                "recipient": recipient,
                "confirmation_code": confirmation_code,
                "created_at": datetime.now(),
                "anomaly_log_id": str(anomaly_log.log_id)
            }
            
            # Send email notification if configured
            if email_notifier and user_profile.email_for_alerts:
                try:
                    await email_notifier.send_suspicious_transaction_alert(
                        email=user_profile.email_for_alerts,
                        amount=amount_float,
                        recipient=recipient,
                        confirmation_code=confirmation_code,
                        reasons=reasons
                    )
                    logger.info(f"Sent confirmation email to {user_profile.email_for_alerts}")
                except Exception as e:
                    logger.error(f"Failed to send confirmation email: {e}")
            
            response_data.update({
                "message": (
                    f"Transaction requires confirmation due to unusual activity. "
                    f"A confirmation code has been sent to your registered email. "
                    f"Please confirm within {config.confirmation_timeout_minutes} minutes."
                ),
                "confirmation_id": confirmation_id,
                "requires_confirmation": True
            })
            
            return AnomalyScoreResponse(**response_data)
        
        else:  # action == "allow"
            response_data["message"] = "Transaction approved - low risk detected"
            return AnomalyScoreResponse(**response_data)
        
    except ValidationError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Risk assessment error: {e}")
        raise HTTPException(status_code=500, detail="Risk assessment failed")

@app.post("/confirm-transaction", response_model=TransactionConfirmResponse)
async def confirm_suspicious_transaction(request: TransactionConfirmRequest,
                                       user_data: Dict[str, str] = Depends(verify_token),
                                       db: Session = Depends(get_db)):
    """Confirm a suspicious transaction via confirmation code"""
    try:
        account_id = user_data.get('account_id')
        
        if not account_id:
            raise HTTPException(status_code=400, detail="Account ID not found in token")
        
        confirmation_id = request.confirmation_id
        confirmation_code = request.confirmation_code
        
        # Check if confirmation exists
        if confirmation_id not in pending_confirmations:
            return TransactionConfirmResponse(
                status="error",
                error_message="Invalid or expired confirmation ID"
            )
        
        confirmation_data = pending_confirmations[confirmation_id]
        
        # Verify account matches
        if confirmation_data["account_id"] != account_id:
            return TransactionConfirmResponse(
                status="error",
                error_message="Confirmation does not belong to this account"
            )
        
        # Check if expired
        created_at = confirmation_data["created_at"]
        if (datetime.now() - created_at).total_seconds() > (config.confirmation_timeout_minutes * 60):
            del pending_confirmations[confirmation_id]
            return TransactionConfirmResponse(
                status="error",
                error_message="Confirmation has expired"
            )
        
        # Verify confirmation code
        if confirmation_data["confirmation_code"] != confirmation_code.upper():
            return TransactionConfirmResponse(
                status="error",
                error_message="Invalid confirmation code"
            )
        
        # Mark as confirmed
        repo = AIMetaRepository(db)
        
        # Update anomaly log
        try:
            # This is simplified - would need to update the anomaly log in database
            logger.info(f"Transaction confirmed: {confirmation_id}")
        except Exception as e:
            logger.warning(f"Failed to update anomaly log: {e}")
        
        # Clean up
        del pending_confirmations[confirmation_id]
        
        return TransactionConfirmResponse(
            status="success",
            message="Transaction confirmed successfully. You may now proceed.",
            confirmed_at=datetime.now().isoformat()
        )
        
    except Exception as e:
        logger.error(f"Transaction confirmation error: {e}")
        raise HTTPException(status_code=500, detail="Confirmation failed")

@app.get("/anomaly-logs")
async def get_anomaly_logs(limit: int = 50,
                          user_data: Dict[str, str] = Depends(verify_token),
                          db: Session = Depends(get_db)):
    """Get anomaly logs for account"""
    try:
        account_id = user_data.get('account_id')
        
        if not account_id:
            raise HTTPException(status_code=400, detail="Account ID not found in token")
        
        repo = AIMetaRepository(db)
        logs = repo.get_anomaly_logs(account_id, limit)
        
        log_data = []
        for log in logs:
            log_data.append({
                "log_id": str(log.log_id),
                "transaction_id": log.transaction_id,
                "risk_score": float(log.risk_score),
                "status": log.status,
                "reasons": log.reasons,
                "alerted_at": log.alerted_at.isoformat() if log.alerted_at else None,
                "resolved": log.resolved
            })
        
        return {
            "status": "success",
            "logs": log_data,
            "count": len(log_data)
        }
        
    except Exception as e:
        logger.error(f"Get anomaly logs error: {e}")
        raise HTTPException(status_code=500, detail="Unable to retrieve anomaly logs")

@app.post("/update-thresholds")
async def update_user_thresholds(suspicious_multiplier: float = 3.0,
                                fraud_multiplier: float = 5.0,
                                user_data: Dict[str, str] = Depends(verify_token),
                                db: Session = Depends(get_db)):
    """Update user's anomaly detection thresholds"""
    try:
        account_id = user_data.get('account_id')
        
        if not account_id:
            raise HTTPException(status_code=400, detail="Account ID not found in token")
        
        if suspicious_multiplier <= 0 or fraud_multiplier <= 0:
            raise ValidationError("Multipliers must be positive")
        
        if suspicious_multiplier >= fraud_multiplier:
            raise ValidationError("Suspicious multiplier must be less than fraud multiplier")
        
        repo = AIMetaRepository(db)
        user_profile = repo.get_or_create_user_profile(account_id)
        
        # Update thresholds
        user_profile.threshold_suspicious_multiplier = suspicious_multiplier
        user_profile.threshold_fraud_multiplier = fraud_multiplier
        
        # In a real implementation, would commit the changes to database
        # db.commit()
        
        return {
            "status": "success",
            "message": "Thresholds updated successfully",
            "suspicious_multiplier": suspicious_multiplier,
            "fraud_multiplier": fraud_multiplier
        }
        
    except ValidationError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Update thresholds error: {e}")
        raise HTTPException(status_code=500, detail="Unable to update thresholds")

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", "8080"))
    uvicorn.run(app, host="0.0.0.0", port=port)

# ai-services/anomaly-sage/schemas/score_request.py
"""
Anomaly scoring request schemas
"""

from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List
from datetime import datetime

class AnomalyScoreRequest(BaseModel):
    """Request for anomaly scoring"""
    account_id: str = Field(..., description="Account performing transaction")
    amount_cents: int = Field(..., description="Transaction amount in cents")
    recipient: str = Field(..., description="Transaction recipient")
    transaction_type: str = Field("transfer", description="Type of transaction")
    timestamp: Optional[datetime] = Field(None, description="Transaction timestamp")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional metadata")

class AnomalyScoreResponse(BaseModel):
    """Response from anomaly scoring"""
    status: str = Field(..., description="Risk status: normal, suspicious, fraud")
    risk_score: float = Field(..., description="Numerical risk score (0-10)")
    reasons: List[str] = Field(default_factory=list, description="Reasons for risk assessment")
    action: str = Field(..., description="Recommended action: allow, confirm, block")
    message: Optional[str] = Field(None, description="User-facing message")
    confirmation_id: Optional[str] = Field(None, description="Confirmation ID if confirmation required")
    requires_confirmation: Optional[bool] = Field(False, description="Whether confirmation is required")

# ai-services/anomaly-sage/schemas/score_response.py
"""
Transaction confirmation schemas
"""

from pydantic import BaseModel, Field
from typing import Optional

class TransactionConfirmRequest(BaseModel):
    """Request to confirm suspicious transaction"""
    confirmation_id: str = Field(..., description="Confirmation ID from risk assessment")
    confirmation_code: str = Field(..., description="Confirmation code from email/SMS")

class TransactionConfirmResponse(BaseModel):
    """Response from transaction confirmation"""
    status: str = Field(..., description="Confirmation status: success, error")
    message: Optional[str] = Field(None, description="Success message")
    confirmed_at: Optional[str] = Field(None, description="Confirmation timestamp")
    error_message: Optional[str] = Field(None, description="Error details if failed")

# ai-services/anomaly-sage/risk_model.py
"""
Risk scoring model for anomaly detection
"""

import logging
import statistics
from datetime import datetime, timedelta
from typing import Dict, Any, List
from ..shared.constants import DEFAULT_SUSPICIOUS_MULTIPLIER, DEFAULT_FRAUD_MULTIPLIER

logger = logging.getLogger(__name__)

class RiskScoreCalculator:
    """Calculates risk scores for transactions using statistical analysis"""
    
    def __init__(self):
        self.base_risk_factors = {
            "large_amount": 2.0,
            "unusual_time": 1.5,
            "new_recipient": 1.2,
            "high_frequency": 1.8,
            "weekend_transaction": 1.1
        }
    
    async def calculate_risk_score(self, account_id: str, amount_cents: int, 
                                  recipient: str, timestamp: datetime,
                                  user_profile, repo) -> Dict[str, Any]:
        """
        Calculate comprehensive risk score for transaction
        
        Returns:
            Dict with risk_score and reasons
        """
        try:
            risk_score = 0.0
            reasons = []
            
            # 1. Amount-based risk (Z-score analysis)
            amount_risk, amount_reasons = self._calculate_amount_risk(
                amount_cents, user_profile
            )
            risk_score += amount_risk
            reasons.extend(amount_reasons)
            
            # 2. Time-based risk
            time_risk, time_reasons = self._calculate_time_risk(timestamp, user_profile)
            risk_score += time_risk
            reasons.extend(time_reasons)
            
            # 3. Recipient-based risk
            recipient_risk, recipient_reasons = await self._calculate_recipient_risk(
                account_id, recipient, repo
            )
            risk_score += recipient_risk
            reasons.extend(recipient_reasons)
            
            # 4. Frequency-based risk
            frequency_risk, frequency_reasons = await self._calculate_frequency_risk(
                account_id, timestamp, repo
            )
            risk_score += frequency_risk
            reasons.extend(frequency_reasons)
            
            # 5. Pattern-based risk
            pattern_risk, pattern_reasons = await self._calculate_pattern_risk(
                account_id, amount_cents, recipient, timestamp, repo
            )
            risk_score += pattern_risk
            reasons.extend(pattern_reasons)
            
            # Cap risk score at 10.0
            risk_score = min(risk_score, 10.0)
            
            logger.info(f"Risk calculated for account {account_id}: score={risk_score:.4f}, "
                       f"reasons={len(reasons)}")
            
            return {
                "risk_score": risk_score,
                "reasons": reasons[:5],  # Limit to top 5 reasons
                "components": {
                    "amount_risk": amount_risk,
                    "time_risk": time_risk,
                    "recipient_risk": recipient_risk,
                    "frequency_risk": frequency_risk,
                    "pattern_risk": pattern_risk
                }
            }
            
        except Exception as e:
            logger.error(f"Risk calculation error: {e}")
            return {
                "risk_score": 0.0,
                "reasons": ["Risk calculation failed"],
                "error": str(e)
            }
    
    def _calculate_amount_risk(self, amount_cents: int, user_profile) -> tuple[float, List[str]]:
        """Calculate risk based on transaction amount using Z-score"""
        risk = 0.0
        reasons = []
        
        try:
            amount_dollars = amount_cents / 100
            
            # Use user profile statistics if available
            if (user_profile.mean_txn_amount_cents and 
                user_profile.stddev_txn_amount_cents and
                user_profile.stddev_txn_amount_cents > 0):
                
                mean_dollars = float(user_profile.mean_txn_amount_cents) / 100
                stddev_dollars = float(user_profile.stddev_txn_amount_cents) / 100
                
                # Calculate Z-score
                z_score = (amount_dollars - mean_dollars) / stddev_dollars
                
                if z_score > 3.0:  # More than 3 standard deviations
                    risk += 3.0
                    reasons.append(f"Amount ${amount_dollars:,.2f} is unusually large (z-score: {z_score:.2f})")
                elif z_score > 2.0:
                    risk += 2.0
                    reasons.append(f"Amount ${amount_dollars:,.2f} is significantly above average")
                elif z_score > 1.5:
                    risk += 1.0
                    reasons.append(f"Amount ${amount_dollars:,.2f} is above normal range")
            else:
                # Fallback to absolute thresholds
                if amount_dollars > 5000:
                    risk += 3.0
                    reasons.append(f"Large transaction amount: ${amount_dollars:,.2f}")
                elif amount_dollars > 1000:
                    risk += 1.5
                    reasons.append(f"Elevated transaction amount: ${amount_dollars:,.2f}")
            
            # Additional checks for very large amounts
            if amount_dollars > 10000:
                risk += 2.0
                reasons.append("Transaction exceeds $10,000 threshold")
        
        except Exception as e:
            logger.error(f"Amount risk calculation error: {e}")
            risk = 0.5  # Small penalty for calculation failure
            reasons.append("Unable to assess amount risk")
        
        return risk, reasons
    
    def _calculate_time_risk(self, timestamp: datetime, user_profile) -> tuple[float, List[str]]:
        """Calculate risk based on transaction time"""
        risk = 0.0
        reasons = []
        
        try:
            # Check if transaction is outside active hours
            active_hours = user_profile.active_hours or [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
            transaction_hour = timestamp.hour
            
            if transaction_hour not in active_hours:
                risk += 1.0
                reasons.append(f"Transaction at unusual time: {timestamp.strftime('%H:%M')}")
            
            # Weekend transactions (slight risk increase)
            if timestamp.weekday() >= 5:  # Saturday = 5, Sunday = 6
                risk += 0.5
                reasons.append("Weekend transaction")
            
            # Very late night or very early morning
            if transaction_hour >= 23 or transaction_hour <= 5:
                risk += 1.5
                reasons.append(f"Late night/early morning transaction: {timestamp.strftime('%H:%M')}")
        
        except Exception as e:
            logger.error(f"Time risk calculation error: {e}")
        
        return risk, reasons
    
    async def _calculate_recipient_risk(self, account_id: str, recipient: str, repo) -> tuple[float, List[str]]:
        """Calculate risk based on recipient patterns"""
        risk = 0.0
        reasons = []
        
        try:
            # Check if recipient is new (simplified check)
            annotations = repo.get_transaction_annotations(account_id, 100)
            
            # Look for previous transactions to this recipient
            previous_transactions = [
                a for a in annotations 
                if a.merchant_name and recipient in a.merchant_name
            ]
            
            if not previous_transactions:
                risk += 1.0
                reasons.append(f"New recipient: {recipient}")
            
            # Check if recipient looks like an account number vs contact name
            if recipient.isdigit() and len(recipient) >= 10:
                risk += 0.5
                reasons.append("Transaction to raw account number")
        
        except Exception as e:
            logger.error(f"Recipient risk calculation error: {e}")
        
        return risk, reasons
    
    async def _calculate_frequency_risk(self, account_id: str, timestamp: datetime, repo) -> tuple[float, List[str]]:
        """Calculate risk based on transaction frequency"""
        risk = 0.0
        reasons = []
        
        try:
            # Check recent transaction frequency (simplified)
            # In a real implementation, would query actual transaction history
            
            # For now, use annotations as proxy
            recent_annotations = repo.get_transaction_annotations(account_id, 50)
            
            # Count transactions in last hour/day (simplified)
            # This is a placeholder - would need actual timestamps
            if len(recent_annotations) > 20:
                risk += 1.5
                reasons.append("High recent transaction frequency")
        
        except Exception as e:
            logger.error(f"Frequency risk calculation error: {e}")
        
        return risk, reasons
    
    async def _calculate_pattern_risk(self, account_id: str, amount_cents: int, 
                                    recipient: str, timestamp: datetime, repo) -> tuple[float, List[str]]:
        """Calculate risk based on unusual patterns"""
        risk = 0.0
        reasons = []
        
        try:
            # Round number amounts (potential indicator of manual/unusual transactions)
            amount_dollars = amount_cents / 100
            if amount_dollars == int(amount_dollars) and amount_dollars >= 100:
                if amount_dollars % 100 == 0:  # Multiples of 100
                    risk += 0.5
                    reasons.append(f"Round amount: ${amount_dollars:,.0f}")
            
            # Very specific amounts (like $1337.00, $9999.00) could be suspicious
            suspicious_amounts = [1337, 9999, 6666, 1234, 4321]
            if int(amount_dollars) in suspicious_amounts:
                risk += 1.0
                reasons.append(f"Potentially suspicious amount pattern: ${amount_dollars:,.0f}")
        
        except Exception as e:
            logger.error(f"Pattern risk calculation error: {e}")
        
        return risk, reasons

# ai-services/anomaly-sage/thresholds.py
"""
Threshold management for anomaly detection
"""

import logging
from typing import Dict, Any, Tuple
from ..shared.constants import DEFAULT_SUSPICIOUS_MULTIPLIER, DEFAULT_FRAUD_MULTIPLIER

logger = logging.getLogger(__name__)

class ThresholdManager:
    """Manages risk thresholds and classification"""
    
    def __init__(self):
        self.default_thresholds = {
            "suspicious_threshold": 2.0,
            "fraud_threshold": 4.0
        }
    
    def get_user_thresholds(self, user_profile) -> Dict[str, float]:
        """Get risk thresholds for user"""
        try:
            if not user_profile:
                return self.default_thresholds
            
            # Calculate dynamic thresholds based on user's transaction patterns
            base_threshold = 1.0
            
            if (user_profile.mean_txn_amount_cents and 
                user_profile.stddev_txn_amount_cents):
                
                # Use user's statistical profile to adjust thresholds
                suspicious_multiplier = float(user_profile.threshold_suspicious_multiplier or DEFAULT_SUSPICIOUS_MULTIPLIER)
                fraud_multiplier = float(user_profile.threshold_fraud_multiplier or DEFAULT_FRAUD_MULTIPLIER)
                
                return {
                    "suspicious_threshold": base_threshold * suspicious_multiplier,
                    "fraud_threshold": base_threshold * fraud_multiplier
                }
            
            return self.default_thresholds
            
        except Exception as e:
            logger.error(f"Error getting user thresholds: {e}")
            return self.default_thresholds
    
    def classify_risk(self, risk_score: float, thresholds: Dict[str, float]) -> Tuple[str, str]:
        """
        Classify risk level and determine action
        
        Returns:
            (status, action) tuple
        """
        try:
            suspicious_threshold = thresholds.get("suspicious_threshold", 2.0)
            fraud_threshold = thresholds.get("fraud_threshold", 4.0)
            
            if risk_score >= fraud_threshold:
                return "fraud", "block"
            elif risk_score >= suspicious_threshold:
                return "suspicious", "confirm"
            else:
                return "normal", "allow"
                
        except Exception as e:
            logger.error(f"Risk classification error: {e}")
            return "normal", "allow"  # Fail safe
    
    def update_user_thresholds(self, user_profile, suspicious_multiplier: float, 
                              fraud_multiplier: float) -> bool:
        """Update user's threshold multipliers"""
        try:
            if suspicious_multiplier <= 0 or fraud_multiplier <= 0:
                return False
            
            if suspicious_multiplier >= fraud_multiplier:
                return False
            
            user_profile.threshold_suspicious_multiplier = suspicious_multiplier
            user_profile.threshold_fraud_multiplier = fraud_multiplier
            
            return True
            
        except Exception as e:
            logger.error(f"Error updating thresholds: {e}")
            return False

# ai-services/anomaly-sage/email_notifier.py
"""
Email notification service for suspicious transactions
"""

import asyncio
import logging
from typing import Dict, Any, List, Optional
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

logger = logging.getLogger(__name__)

class EmailNotifier:
    """Sends email notifications for suspicious transactions"""
    
    def __init__(self, email_config: Dict[str, str]):
        self.smtp_server = email_config.get("smtp_server")
        self.smtp_port = int(email_config.get("smtp_port", 587))
        self.username = email_config.get("username")
        self.password = email_config.get("password")
        self.from_email = email_config.get("from_email")
        self.enabled = all([self.smtp_server, self.username, self.password, self.from_email])
        
        if not self.enabled:
            logger.warning("Email notification not configured properly")
    
    async def send_suspicious_transaction_alert(self, email: str, amount: float, 
                                              recipient: str, confirmation_code: str,
                                              reasons: List[str]) -> bool:
        """Send email alert for suspicious transaction"""
        if not self.enabled:
            logger.warning("Email notifications disabled")
            return False
        
        try:
            subject = " Bank of Anthos - Transaction Confirmation Required"
            
            # Create email content
            html_content = self._create_suspicious_transaction_email(
                amount, recipient, confirmation_code, reasons
            )
            text_content = self._create_text_email(amount, recipient, confirmation_code, reasons)
            
            # Send email